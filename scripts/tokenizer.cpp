/*****************************************************************************************************************************************
 *
 * Tokenizer C++ version (2025)
 * ----------------------------
 * This version is an automatic conversion generated by IA from the other available versions (Python, Shell, Javascript and PHP).
 * This code has not been revised, but the output results have been verified and are consistent with the results of the other versions.
 * 
 *****************************************************************************************************************************************/

#include <iostream>
#include <iomanip>
#include <sstream>
#include <string>
#include <vector>

#include <termios.h>	//-- linux
#include <unistd.h>	//-- linux

//#include <conio.h>	//-- windows

#include <openssl/hmac.h>
#include <openssl/evp.h>
#include <openssl/sha.h>
#include <openssl/err.h>
#include <openssl/buffer.h>

//--[ SHA512 digest inputs ]------------------------------------------------------------

std::string tokenizer_SHA512(const std::string& input)
{
	unsigned char hash[SHA512_DIGEST_LENGTH];
	SHA512(reinterpret_cast<const unsigned char*>(input.c_str()), input.size(), hash);
	std::ostringstream oss;
	for (int i = 0; i < SHA512_DIGEST_LENGTH; ++i) oss << std::hex << std::setw(2) << std::setfill('0') << static_cast<int>(hash[i]);
	return oss.str();
}

//--[ Tokenize with PBKDF2 ]------------------------------------------------------------

std::string tokenizer_PBKDF2(const std::string& password, const std::string& salt)
{
	const int iterations = 300000;
	const int keyLength = 64;
	std::vector<unsigned char> key(keyLength);
	if (PKCS5_PBKDF2_HMAC(password.c_str(), password.length(),
	reinterpret_cast<const unsigned char*>(salt.c_str()), salt.length(), iterations, EVP_sha256(), keyLength, key.data()) == 0)
	{
		ERR_print_errors_fp(stderr);
		return "";
	}

	std::ostringstream oss;
	for (const auto& byte : key) oss << std::hex << std::setw(2) << std::setfill('0') << static_cast<int>(byte);
	return oss.str();
}

//--[ Tokenize with HMAC ]--------------------------------------------------------------

std::string tokenizer_HMAC512(const std::string& key, const std::string& message)
{
	unsigned char* result;
	unsigned int result_len = EVP_MAX_MD_SIZE;
	std::vector<unsigned char> hmac(result_len);
	result = HMAC(EVP_sha512(), key.c_str(), key.length(),
	reinterpret_cast<const unsigned char*>(message.c_str()), message.length(),
	hmac.data(), &result_len);
	std::ostringstream oss;
	for (unsigned int i = 0; i < result_len; ++i) oss << std::hex << std::setw(2) << std::setfill('0') << static_cast<int>(result[i]);
	return oss.str();
}

//--[ Tokenize SHA1 + BASE64 ]----------------------------------------------------------

unsigned long hex2dec(const std::string& hex) { return std::stoul(hex, nullptr, 16); }

std::vector<unsigned char> hex2bytes(const std::string& hex)
{
	std::vector<unsigned char> bytes;
	for (size_t i = 0; i < hex.length(); i += 2)
	{
		std::string byteString = hex.substr(i, 2);
		unsigned char byte = static_cast<unsigned char>(strtol(byteString.c_str(), nullptr, 16));
		bytes.push_back(byte);
	}
	return bytes;
}

std::string b64(const unsigned char* buffer, size_t length)
{
	BIO* bio;
	BIO* b64;
	BUF_MEM* bufferPtr;
	b64 = BIO_new(BIO_f_base64());
	bio = BIO_new(BIO_s_mem());
	bio = BIO_push(b64, bio);
	BIO_set_flags(bio, BIO_FLAGS_BASE64_NO_NL);
	BIO_write(bio, buffer, length);
	BIO_flush(bio);
	BIO_get_mem_ptr(bio, &bufferPtr);
	BIO_set_close(bio, BIO_NOCLOSE);
	BIO_free_all(bio);
	std::string result(bufferPtr->data, bufferPtr->length);
	return result;
}

//--[ Tokenize + PIN ]------------------------------------------------------------------

std::string tokenizer(const std::string& token)
{
	std::vector<unsigned char> bytes = hex2bytes(token);
	unsigned char token_sha1[SHA_DIGEST_LENGTH];
	SHA1(bytes.data(), bytes.size(), token_sha1);
	return b64(token_sha1, SHA_DIGEST_LENGTH);
}

unsigned long token2pin(const std::string& hmac_key) // TO-BE-FIX
{
	std::vector<unsigned char> bytes = hex2bytes(hmac_key);
	std::ostringstream hex_stream;
	for (unsigned char byte : bytes) hex_stream << std::hex << std::setw(2) << std::setfill('0') << static_cast<int>(byte);
	std::string hex_data = hex_stream.str();
	std::vector<std::string> hex_words;
	for (size_t i = 0; i < hex_data.length(); i += 6) hex_words.push_back(hex_data.substr(i, 6));
	unsigned long pin_code = hex2dec(hex_words[0]);
	for (size_t i = 1; i < hex_words.size(); ++i) if (!hex_words[i].empty()) pin_code ^= hex2dec(hex_words[i]);
	return pin_code;
}


//--[ Hidden password inputs (linux/windows) ]------------------------------------------

std::string nix_getPassword()
{
	std::string password;
	struct termios oldt, newt;
	tcgetattr(STDIN_FILENO, &oldt);
	newt = oldt;
	newt.c_lflag &= ~(ECHO);
	tcsetattr(STDIN_FILENO, TCSANOW, &newt);
	std::cout << "Password: ";
	std::getline(std::cin, password);
	tcsetattr(STDIN_FILENO, TCSANOW, &oldt);
	std::cout << std::endl;
	return password;
}

/*
std::string win_getPassword() // TO-BE-TEST
{
	char ch;
	std::string password;
	std::cout << "Password: ";
	while ((ch = _getch()) != '\r') password.push_back(ch);
	std::cout << std::endl;
	return password;
}
*/

//--[ User input ] ---------------------------------------------------------------------

int main()
{
	std::string user, password, login, server, token;

	std::cout << "User: ";
	std::getline(std::cin, user);

	password = nix_getPassword();
	std::cout << std::endl;

	std::cout << "Login: ";
	std::getline(std::cin, login);

	std::cout << "Server: ";
	std::getline(std::cin, server);

	std::string host = tokenizer_SHA512(login + server);
	std::string auth = tokenizer_SHA512(user + host);
	std::string key = tokenizer_SHA512(password);

	std::string pbkdf_key = tokenizer_PBKDF2(auth, key);
	std::string hmac_key = tokenizer_HMAC512(pbkdf_key, host);

	token = tokenizer(hmac_key);
	//unsigned long pin_code = token2pin(hmac_key);

	std::cout << std::endl;
	std::cout << "Token: !" << token << std::endl;
	//std::cout << "PIN: " << pin_code << std::endl;

	return 0;
}

