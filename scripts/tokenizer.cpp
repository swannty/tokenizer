/*****************************************************************************************************************************************
 *
 * Tokenizer C++ version (2025)
 * ----------------------------
 * This version is an automatic conversion generated by IA from the other available versions (Python, Shell, Javascript and PHP).
 * This code has not been revised, but the output results have been verified and are consistent with the results of the other versions.
 *
 * Build: g++ tokenizer.cpp -lssl -lcrypto -static -static-libgcc -static-libstdc++ -o tokenizer 
 *
 *****************************************************************************************************************************************/

#include <iostream>
#include <iomanip>
#include <sstream>
#include <string>
#include <vector>

#include <termios.h>	//-- linux
#include <unistd.h>	//-- linux

//#include <conio.h>	//-- windows

#include <openssl/hmac.h>
#include <openssl/evp.h>
#include <openssl/sha.h>
#include <openssl/buffer.h>

//--[ HIDDEN KEYBOARD INPUT ]---------------------------------------------------------

std::string getPassword() //-- linux
{
	std::string password;
	struct termios oldt, newt;
	tcgetattr(STDIN_FILENO, &oldt);
	newt = oldt;
	newt.c_lflag &= ~(ECHO);
	tcsetattr(STDIN_FILENO, TCSANOW, &newt);
	std::cout << "Password: ";
	std::getline(std::cin, password);
	tcsetattr(STDIN_FILENO, TCSANOW, &oldt);
	std::cout << std::endl;
	return password;
}

/*
std::string getPassword() //-- windows
{
	char ch;
	std::string password;
	std::cout << "Password: ";
	while ((ch = _getch()) != '\r') password.push_back(ch);
	std::cout << std::endl;
	return password;
}
*/

//--[ BASE64 ]------------------------------------------------------------------------

std::string b64(const unsigned char* buffer, size_t length)
{
	BIO* bio;
	BIO* b64;
	BUF_MEM* bufferPtr;
	b64 = BIO_new(BIO_f_base64());
	bio = BIO_new(BIO_s_mem());
	bio = BIO_push(b64, bio);
	BIO_set_flags(bio, BIO_FLAGS_BASE64_NO_NL);
	BIO_write(bio, buffer, length);
	BIO_flush(bio);
	BIO_get_mem_ptr(bio, &bufferPtr);
	BIO_set_close(bio, BIO_NOCLOSE);
	BIO_free_all(bio);
	std::string result(bufferPtr->data, bufferPtr->length);
	return result;
}

//--[ HEX > BIN / BIN > HEX ]---------------------------------------------------------

std::vector<unsigned char> hex2bytes(const std::string& hex)
{
	std::vector<unsigned char> bytes;
	for (size_t i = 0; i < hex.length(); i += 2)
	{
		std::string byteString = hex.substr(i, 2);
		unsigned char byte = static_cast<unsigned char>(strtol(byteString.c_str(), nullptr, 16));
		bytes.push_back(byte);
	}
	return bytes;
}

std::string bytes2hex(const unsigned char* bytes, size_t length)
{
	std::ostringstream oss;
	for (size_t i = 0; i < length; ++i) oss << std::hex << std::setw(2) << std::setfill('0') << static_cast<int>(bytes[i]);
	return oss.str();
}

//--[ SHA512 / PBKDF2 / HMAC ]--------------------------------------------------------

std::string sha512(const std::string& input)
{
	unsigned char hash[SHA512_DIGEST_LENGTH];
	SHA512(reinterpret_cast<const unsigned char*>(input.c_str()), input.size(), hash);
	return bytes2hex(hash, SHA512_DIGEST_LENGTH);
}

std::string pbkdf2(const std::string& password, const std::string& salt)
{
	const int keyLength = 64;
	const int iterations = 300000;
	std::vector<unsigned char> key(keyLength);
	PKCS5_PBKDF2_HMAC(password.c_str(), password.length(), reinterpret_cast<const unsigned char*>(salt.c_str()), salt.length(), iterations, EVP_sha256(), keyLength, key.data());
	return bytes2hex(key.data(), keyLength);
}

std::string hmac512(const std::string& key, const std::string& message)
{
	unsigned char* result;
	unsigned int result_len = EVP_MAX_MD_SIZE;
	std::vector<unsigned char> hmac(result_len);
	result = HMAC(EVP_sha512(), key.c_str(), key.length(), reinterpret_cast<const unsigned char*>(message.c_str()), message.length(), hmac.data(), &result_len);
	return bytes2hex(hmac.data(), result_len);
}

//--[ TOKENIZER ]---------------------------------------------------------------------

std::string tokenizer(const std::string& token)
{
	std::vector<unsigned char> bytes = hex2bytes(token);
	unsigned char token_sha1[SHA_DIGEST_LENGTH];
	SHA1(bytes.data(), bytes.size(), token_sha1);
	return b64(token_sha1, SHA_DIGEST_LENGTH);
}

//--[ USER INPUT / TOKEN OUTPUT ]-----------------------------------------------------

int main()
{
	std::string user, password, login, server, token;

	std::cout << "User: ";
	std::getline(std::cin, user);

	password = getPassword();
	std::cout << std::endl;

	std::cout << "Login: ";
	std::getline(std::cin, login);

	std::cout << "Server: ";
	std::getline(std::cin, server);

	std::string host = sha512(login + server);
	std::string auth = sha512(user + host);
	std::string key = sha512(password);

	std::string pbkdf_key = pbkdf2(auth, key);
	std::string hmac_key = hmac512(pbkdf_key, host);

	token = tokenizer(hmac_key);

	std::cout << std::endl;
	std::cout << "Token: !" << token << std::endl;

	return 0;
}

